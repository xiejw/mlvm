From bottom-up view for the design

VM

        design

                vm is the runtime of the system. It could be local or remote.

                vm has only one type for i/o. Tensor.

                VM is responsible for one device type only (CPU/GPU). It handles
                it well and efficiently. All tensors are "local" to this device
                type. Cross device type communication should be explicit.

                All VM's APIs should behave like rpc APIs. So, the values,
                espcially large tensor values, are "copy" sematics, even it is
                local mode. This simplifies the user's mental model. If future
                optimization is needed, special APis must be provided to make
                this crystal clear about the cost.

                vm's memory consists of two parts. stack and free stores. This
                is similar to lua's design. Each execution is expected to finish
                the stack value--remaining values are outputs. Free store is
                subject to gabage collected.  The design space covers whether
                the free store is available across runs. Currently it is.

                vm should provide estimated cost for the memory so far.

                concurrency: Launch must be in sequence. Next one will blocked.
                All other methods are call site's responsibility. Inproper sync
                might lead to race conditions.

      draft API for vm

                type TensorShape  []int
                type TensorHandle int
                type TensorType   int // int, float32, float64, etc.

                type Buffer struct {
                        Size  int
                        DType TensorType
                        Ptr   interface{}
                }

                type Tensor struct {
                        Shape  TensorShape
                        Rank   int
                        Buffer Buffer
                }

                type VM interface {
                        AllocTensor(TensorShape, TensorType) (TensorHandle, error);
                        DeallocTensor(TensorHandle) error;
                        Read(TensorHandle, *Buffer) error;
                        Write(TensorHandle, *Buffer) error;
                        Launch(Program) ([]*Tensor,  error)
                        ConsumedSizeInMiB() float32
                }

        C func call

                Name. C func name is picked up stack. Str type.  It is registed
                in vm lookup table.

                vm's base is adjusted temporarily, and vm will remembers how
                many params, called nparams, to pass to C func. So the base-1 is
                the last param; while base-nparams is the first param.

                Func call return count is code after OP_CFUNC. every thing left
                between base and top is return values. they are moved to
                base-nparams. can return count is adjusted.

                base and nparams is adjusted back afte call.

