package main

import (
	"log"
	"os"
	"text/template"
)

// Define a template.
const code = `// Code generated by 'make generate'. DO NOT EDIT
package {{.Package}}

{{.Comment}}
type {{.Name}} interface {
	Iterator() <-chan {{.Type}}
	Count() int
}

type {{.ImplName}} struct {
	data      []{{.Type}}
	finalized bool
}

func (impl *{{.ImplName}}) Count() int {
	if !impl.finalized {
		panic("The Build should be called first.")
	}
	return len(impl.data)
}

func (impl *{{.ImplName}}) Iterator() <-chan {{.Type}} {
	if !impl.finalized {
		panic("The Build should be called first.")
	}
	c := make(chan {{.Type}})
	go func() {
		for _, item := range impl.data {
			c <- item
		}
		close(c)
	}()
	return c
}

func (impl *{{.ImplName}}) Append(item {{.Type}}) {
	impl.data = append(impl.data, item)
}

func (impl *{{.ImplName}}) Build() {
	if impl.finalized {
		panic("The Build should not be called twice.")
	}
	impl.finalized = true
}
`

func main() {
	type Context struct {
		Package, Name, Type, Comment string
		ImplName                     string
	}

	c := Context{
		Package:  "layers",
		Comment:  "// Template: Inputs of layers. Typically a list of `Layer`s.",
		Name:     "InputsTemplate",
		Type:     "Layer",
		ImplName: "InputsBuilder",
	}

	t := template.Must(template.New("code").Parse(code))

	// Execute the template.
	err := t.Execute(os.Stdout, c)
	if err != nil {
		log.Println("executing template:", err)
	}
}
